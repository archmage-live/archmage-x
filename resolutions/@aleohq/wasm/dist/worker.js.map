{"version":3,"file":"worker.js","sources":["../js/worker.js"],"sourcesContent":["import wasm from \"../Cargo.toml\";\n\nexport async function initializeWorker() {\n    // Wait for the main thread to send us the Module, Memory, and Rayon thread pointer.\n    function wait() {\n        return new Promise((resolve) => {\n            addEventListener(\"message\", (event) => {\n                resolve(event.data);\n            }, {\n                capture: true,\n                once: true,\n            });\n        });\n    }\n\n    const [initWasm, { module, memory, address }] = await Promise.all([\n        wasm,\n        wait(),\n    ]);\n\n    // Runs the Wasm inside of the Worker, but using the main thread's Module and Memory.\n    const exports = await initWasm({\n        initializeHook: (init, path) => init(module, memory),\n    });\n\n    // Tells the main thread that we're finished initializing.\n    postMessage(null);\n\n    // This will hang the Worker while running the Rayon thread.\n    exports.runRayonThread(address);\n\n    // When the Rayon thread is finished, close the Worker.\n    close();\n}\n"],"names":[],"mappings":";;AAEO,eAAe,gBAAgB,GAAG;AACzC;AACA,IAAI,SAAS,IAAI,GAAG;AACpB,QAAQ,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,KAAK;AACxC,YAAY,gBAAgB,CAAC,SAAS,EAAE,CAAC,KAAK,KAAK;AACnD,gBAAgB,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AACpC,aAAa,EAAE;AACf,gBAAgB,OAAO,EAAE,IAAI;AAC7B,gBAAgB,IAAI,EAAE,IAAI;AAC1B,aAAa,CAAC,CAAC;AACf,SAAS,CAAC,CAAC;AACX,KAAK;AACL;AACA,IAAI,MAAM,CAAC,QAAQ,EAAE,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;AACtE,QAAQ,IAAI;AACZ,QAAQ,IAAI,EAAE;AACd,KAAK,CAAC,CAAC;AACP;AACA;AACA,IAAI,MAAM,OAAO,GAAG,MAAM,QAAQ,CAAC;AACnC,QAAQ,cAAc,EAAE,CAAC,IAAI,EAAE,IAAI,KAAK,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC;AAC5D,KAAK,CAAC,CAAC;AACP;AACA;AACA,IAAI,WAAW,CAAC,IAAI,CAAC,CAAC;AACtB;AACA;AACA,IAAI,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;AACpC;AACA;AACA,IAAI,KAAK,EAAE,CAAC;AACZ;;;;"}